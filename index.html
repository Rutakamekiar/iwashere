<!-- Based on original index.html :contentReference[oaicite:0]{index=0} -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Region Selector (OSM IDs with Coordinates)</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
    />
    <style>
      body {
        margin: 0;
      }
      #map {
        width: 100%;
        height: 90vh;
      }
      #controls {
        padding: 5px;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div id="controls">
      <button id="clearAll">Clear All</button>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <script>
      // ─── Setup ─────────────────────────────────────────
      const map = L.map("map").setView([20, 0], 2);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
      }).addTo(map);

      // Group for drawn regions
      const selectionGroup = L.featureGroup().addTo(map);
      // Store objects: { id: 'N123', lat, lng }
      let selectedOsmData = [];
      // Track which IDs have been restored/drawn
      const restoredIds = new Set();
      // Debounce handle for restore calls
      let restoreTimeout;

      // ─── Load stored data ───────────────────────────────────
      window.addEventListener("load", () => {
        const stored = localStorage.getItem("selectedOsmData");
        if (stored) {
          try {
            selectedOsmData = JSON.parse(stored);
          } catch (e) {
            console.error("Invalid stored data", e);
          }
        }
        // schedule initial restore after setting view via geo or IP
      });

      // ─── Geolocation: HTML5 → IP fallback ─────────────
      function onGeoSuccess(position) {
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;
        map.setView([lat, lng], 13);
        scheduleRestore();
      }
      function onGeoError(err) {
        console.warn("Geolocation error:", err);
        lookupByIP();
      }
      function lookupByIP() {
        fetch("https://ipapi.co/json/")
          .then((res) => res.json())
          .then((data) => {
            const { latitude: lat, longitude: lng } = data;
            map.setView([lat, lng], 10);
            scheduleRestore();
          })
          .catch(console.error);
      }
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(onGeoSuccess, onGeoError, {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 0,
        });
      } else {
        lookupByIP();
      }

      // ─── Reverse lookup with 2 s delay ─────────────────────
      async function fetchOsmWithGeo(lat, lng, zoomLevel) {
        // throttle reverse lookups by 2 s
        await new Promise((res) => setTimeout(res, 5000));
        const url = new URL("https://nominatim.openstreetmap.org/reverse");
        url.search = new URLSearchParams({
          format: "json",
          lat,
          lon: lng,
          zoom: zoomLevel,
          polygon_geojson: 1,
          addressdetails: 0,
        });
        const response = await fetch(url);
        return response.json();
      }

      async function fetchBestOsmGeo(lat, lng, zoomLevels = [10, 12, 8]) {
        let data;

        for (const zoom of zoomLevels) {
          data = await fetchOsmWithGeo(lat, lng, zoom);

          // If we got more than just a point, we’re done
          if (!data.geojson || data.geojson.type !== "Point") {
            console.log(
              `Got ${data.geojson?.type || "no geojson"} at zoom ${zoom}`
            );
            return data;
          }

          // Otherwise log and continue to next zoom level
          console.log(`Only a Point at zoom ${zoom}, trying next…`);
        }

        // If all zoom levels yielded only a Point, return the last one
        console.warn(
          `All zoom levels [${zoomLevels.join(", ")}] returned only a Point.`
        );
        return data;
      }

      // ─── Merge all layers ──────────────────────────────────
      function mergeRegions() {
        const gj = selectionGroup.toGeoJSON();
        if (!gj.features.length) return;
        const merged = gj.features.reduce(
          (acc, feat) => (acc ? turf.union(acc, feat) : feat),
          null
        );
        selectionGroup.clearLayers();
        if (merged) L.geoJSON(merged).addTo(selectionGroup);
      }

      // ─── Restore regions currently in view (only new IDs) ───
      async function restoreRegionsByOsmCoords() {
        if (!selectedOsmData.length) return;
        const bounds = map.getBounds();
        const toRestore = selectedOsmData.filter(
          (d) => bounds.contains([d.lat, d.lng]) && !restoredIds.has(d.id)
        );
        if (!toRestore.length) return;
        const chunkSize = 50;
        for (let i = 0; i < toRestore.length; i += chunkSize) {
          if (i > 0) await new Promise((r) => setTimeout(r, 5000));
          const chunk = toRestore.slice(i, i + chunkSize);
          const ids = chunk.map((d) => d.id).join(",");
          const url = new URL("https://nominatim.openstreetmap.org/lookup");
          url.search = new URLSearchParams({
            format: "json",
            osm_ids: ids,
            polygon_geojson: 1,
            addressdetails: 0,
          });
          try {
            const features = await fetch(url).then((r) => r.json());
            features.forEach((f, idx) => {
              if (f.geojson) {
                L.geoJSON(f.geojson).addTo(selectionGroup);
                restoredIds.add(chunk[idx].id);
              }
            });
          } catch (err) {
            console.error("Restore chunk failed", err);
          }
        }
        mergeRegions();
      }

      // ─── Click handler ────────────────────────────────────
      async function handleMapClick(e) {
        console.log(e.latlng);
        const { lat, lng } = e.latlng;
        const point = turf.point([lng, lat]);
        console.log(point);
        if (
          selectionGroup
            .toGeoJSON()
            .features.some((f) => turf.booleanPointInPolygon(point, f))
        ) {
          return;
        }
        try {
          let data = await fetchBestOsmGeo(lat, lng);

          const id = data.osm_type.charAt(0).toUpperCase() + data.osm_id;
          if (!selectedOsmData.find((d) => d.id === id)) {
            selectedOsmData.push({ id, lat, lng });
            localStorage.setItem(
              "selectedOsmData",
              JSON.stringify(selectedOsmData)
            );
            if (data.geojson) {
              L.geoJSON(data.geojson).addTo(selectionGroup);
              restoredIds.add(id);
              mergeRegions();
            }
          }
        } catch (err) {
          console.error(err);
        }
      }

      // ─── Scheduling restore calls (debounce) ─────────────
      function scheduleRestore() {
        clearTimeout(restoreTimeout);
        restoreTimeout = setTimeout(restoreRegionsByOsmCoords, 500);
      }

      // ─── Clear all selections ─────────────────────────────
      function clearAllHandler() {
        selectedOsmData = [];
        restoredIds.clear();
        selectionGroup.clearLayers();
        localStorage.removeItem("selectedOsmData");
      }

      // ─── Event bindings ────────────────────────────────────
      map.on("click", handleMapClick);
      map.on("zoomend moveend", scheduleRestore);
      document
        .getElementById("clearAll")
        .addEventListener("click", clearAllHandler);
    </script>

    <!-- Include your coordinate-extractor helper -->
    <script src="script.js"></script>
    <!-- ─── Import Google Location History ───────────────────── -->
    <script>
      const controls = document.getElementById("controls");
      controls.insertAdjacentHTML(
        "beforeend",
        `
      <button id="importBtn">Import Locations</button>
      <input type="file" id="importFile" accept=".json" style="display:none" />
    `
      );

      const importBtn = document.getElementById("importBtn");
      const importFile = document.getElementById("importFile");

      importBtn.addEventListener("click", () => importFile.click());
      importFile.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (evt) => {
          console.log("file parsed");
          let data;
          try {
            data = JSON.parse(evt.target.result);
          } catch (err) {
            return alert("JSON parse error: " + err.message);
          }
          // extract coords via your script.js helper
          const coords = getCoordinates(data);
          console.log("coords extracted, length: " + coords.length);
          // feed each into handleMapClick, with 2 s pause
          for (let i = 0; i < coords.length; i++) {
            const { lat, lng } = coords[i];
            await handleMapClick({ latlng: { lat, lng } });
          }
        };
        reader.readAsText(file);
        importFile.value = "";
      });
    </script>
  </body>
</html>
